/*******************************************************************************
 *                         Poor man's keyboard driver                          *
 *******************************************************************************/

// DOCS:
//  https://www.s100computers.com/My%20System%20Pages/MSDOS%20Board/PC%20Keyboard.pdf

#include "poors_man_keyboard_driver.h"
#include "instruction_wrappers.h"

#include "util.h"
#include "kernel_stdio.h"


static u8 convert_scancode_to_ASCII(u8 scan_code)
{
    // Quick and dirty solution for reading at least letters and numbers
    // Proper solution will need a lot more code to check/support scan code sets,
    // support upper/lower cases, control/alt/shift combinations...
    // NOTE: 0x3F is ASCII for '?'
    static u8 scancode_to_ASCII_table[256] =
    {
        // 0    1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
        //                                                             A     B     C     D     E     F
        0x3F, 0x3F,  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  '0',  '-',  '=', '\b', '\t',  //  0
         'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  'o',  'p',  '[',  ']', '\n', 0x3F,  'a',  's',  // 16  / 0x10
         'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';', 0x27, 0x3F, 0x3F, '\\',  'z',  'x',  'c',  'v',  // 32  / 0x20
         'b',  'n',  'm',  ',',  '.',  '/', 0x3F, 0x3F, 0x3F,  ' ', 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 48  / 0x30
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  '7',  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',  // 64  / 0x40
         '2',  '3',  '0', 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 80  / 0x50
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 96  / 0x60
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 112 / 0x70

        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 128 / 0x80
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 144 / 0x90
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 160 / 0xA0
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 176 / 0xB0
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 192 / 0xC0
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 208 / 0xD0
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 224 / 0xE0
        0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,  // 240 / 0xF0
    };

#if 0
    // For debugging
    if (scancode_to_ASCII_table[scan_code & ~0x80] == 0x3F)
    {
        kernel_printf("ScanCode = 0x%x / %d \n", scan_code, scan_code);
    }
#endif

    return scancode_to_ASCII_table[scan_code & ~0x80];
}


void keyboard_driver_poll(void)
{
    static u8 previous_scan_code = 0;

    // TODO: Before reading output, check if any data is actually pending (the "Output Buffer Status" bit from Status register on 0x64)
    u8 scan_code = read_byte_from_IO_port(0x60);

#if 0
    if (scan_code != 0xFA)
    {
        kernel_printf("ScanCode   = 0x%x / %d \n", scan_code, scan_code);
    }
#endif

    // I don't remember anymore why this is a special case. Should have documented it
    if (scan_code == 0xFA) return;

    if ((previous_scan_code != scan_code) && ((scan_code & 0x80) == 0x00)) // Switched 0x80 with 0x00 to get the '/' from numpad in output
    {                                                                      // I really need to do a proper controller driver
        u8 ASCII_code = convert_scancode_to_ASCII(scan_code);
        event_on_keypress(ASCII_code);
    }

    previous_scan_code = scan_code;
}
